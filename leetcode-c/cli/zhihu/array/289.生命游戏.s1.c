/*
 * @lc app=leetcode.cn id=289 lang=c
 *
 * [289] 生命游戏
 *
 * https://leetcode.cn/problems/game-of-life/description/
 *
 * algorithms
 * Medium (75.69%)
 * Likes:    483
 * Dislikes: 0
 * Total Accepted:    72.7K
 * Total Submissions: 96.1K
 * Testcase Example:  '[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]'
 *
 * 根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。
 * 
 * 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为
 * 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
 * 
 * 
 * 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
 * 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
 * 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
 * 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
 * 
 * 
 * 下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board
 * 的当前状态，返回下一个状态。
 * 
 * 
 * 
 * 示例 1：
 * 
 * 
 * 输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
 * 输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
 * 
 * 
 * 示例 2：
 * 
 * 
 * 输入：board = [[1,1],[1,0]]
 * 输出：[[1,1],[1,1]]
 * 
 * 
 * 
 * 
 * 提示：
 * 
 * 
 * m == board.length
 * n == board[i].length
 * 1 <= m, n <= 25
 * board[i][j] 为 0 或 1
 * 
 * 
 * 
 * 
 * 进阶：
 * 
 * 
 * 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
 * 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？
 * 
 * 
 */
#include <stdbool.h>
#include <stdlib.h>


// @lc code=start

static int live_neighbors(int **board, int m, int n, int i, int j)
{
        int live = 0;
        for (int x = i - 1; x <= i + 1; x++) {
                for (int y = j - 1; y <= j + 1; y++) {
                        if (x == i && y == j) continue;

                        bool valid = x >= 0 && y >= 0 && x < m && y < n;
                        if (!valid) continue;

                        if (abs(board[x][y]) == 1) live++;
                }
        }

        return live;
}

/*
 *
 * 遍历 board 中的细胞。
 *
 * 根据数组的细胞状态计算新一轮的细胞状态，这里会用到能同时代表过去状态和现在状态的复合状态。
 *
 * 具体的计算规则如下所示：
 * 规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。
 *         这时候，将细胞值改为 -1，代表这个细胞过去是活的现在死了；
 * 规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。
 *         这时候不改变细胞的值，仍为 1；
 * 规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。
 *         这时候，将细胞的值改为 -1，代表这个细胞过去是活的现在死了。
 *         可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，
 *         因此它们的复合状态也一致；
 * 规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，
 *         将细胞的值改为 2，代表这个细胞过去是死的现在活了。
 *
 * 根据新的规则更新数组；
 *
 * 现在复合状态隐含了过去细胞的状态，所以我们可以在不复制数组的情况下完成原地更新；
 *
 * 对于最终的输出，需要将 board 转成 0，1 的形式。因此这时候需要再遍历
 * 一次数组，将复合状态为 2 的细胞的值改为 1，复合状态为 -1 的细胞的值改为 0。
 *
 * T(n): O(MN)
 * S(n): O(1)
 */
void gameOfLife(int **board, int board_size, int *board_col_size)
{
        int m = board_size;
        int n = board_col_size[0];

        for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                        int live = live_neighbors(board, m, n, i, j);

                        // 规则 2、规则 3
                        if (board[i][j] == 1 && (live < 2 || live > 3))
                                board[i][j] = -1;

                        // 规则 4
                        if (board[i][j] == 0 && live == 3)
                                board[i][j] = 2;
                }
        }

        for (int i = 0; i < m; i++)
                for (int j = 0; j < n; j++)
                        if (board[i][j] > 0) 
                                board[i][j] = 1;
                        else 
                                board[i][j] = 0;
}
// @lc code=end


