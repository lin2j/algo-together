/*
 * @lc app=leetcode.cn id=190 lang=c
 *
 * [190] 颠倒二进制位
 *
 * https://leetcode.cn/problems/reverse-bits/description/
 *
 * algorithms
 * Easy (71.69%)
 * Likes:    611
 * Dislikes: 0
 * Total Accepted:    205.4K
 * Total Submissions: 286.3K
 * Testcase Example:  '00000010100101000001111010011100'
 *
 * 颠倒给定的 32 位无符号整数的二进制位。
 * 
 * 提示：
 * 
 * 
 * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，
 * 输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无
 * 论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
 *
 * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例
 * 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 * 
 * 
 * 
 * 
 * 示例 1：
 * 
 * 
 * 输入：n = 00000010100101000001111010011100
 * 输出：964176192 (00111001011110000010100101000000)
 * 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
 * ⁠    因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
 * 
 * 示例 2：
 * 
 * 
 * 输入：n = 11111111111111111111111111111101
 * 输出：3221225471 (10111111111111111111111111111111)
 * 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
 * ⁠    因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
 * 
 * 
 * 
 * 提示：
 * 
 * 
 * 输入是一个长度为 32 的二进制字符串
 * 
 * 
 * 
 * 
 * 进阶: 如果多次调用这个函数，你将如何优化你的算法？
 * 
 */
#include <stdint.h>

// @lc code=start

const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101
const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011
const uint32_t M4 = 0x0F0F0F0F; // 00001111000011110000111100001111
const uint32_t M8 = 0x00FF00FF; // 00000000111111110000000011111111
                                

/*
 * 分治法
 * 
 * 以 8 位的二进制数为例
 *
 * a b c d e f g h
 *        | 每 4 位交换一次
 * e f g h a b c d
 *        | 每 2 位交换一次
 * g h e f c d a b
 *        | 每 1 位交换一次
 * h g f e d c b a
 */
uint32_t reverseBits(uint32_t n)
{
        /*
        1. 首先，我们知道 （单个二进制码 & 1) = 其本身，所以对于参数 M1，
           可以看成是用来将一串二进制码的奇数位提取出来；
        2. 接着，n >> 1，右移，可以看作是将 n 上原来的偶数位变成奇数位，
           为什么不说奇数位也变成偶数位，是因为右移将第一个奇数位移除了；
        3. 其次，(n >> 1) & M1，就是如1所述，将（n >> 1）的奇数位提取出来，
           也就是原 n 的偶数位；
        4. 再次，(n & M1) << 1，就是先将 n 的奇数位提出来，然后左移，将其
           变成偶数位；
        5. 然后，奇数位(原 n 的偶数位) | 偶数位(原 n 的奇数位)，相或，就达
           到了原 n 的奇数位和偶数位互换的目的；
        */
        n = (n >> 1) & M1 | (n & M1) << 1;
        n = (n >> 2) & M2 | (n & M2) << 2;
        n = (n >> 4) & M4 | (n & M4) << 4;
        n = (n >> 8) & M8 | (n & M8) << 8;

        return n >> 16 | n << 16;
}
// @lc code=end


